# 模块化发展历史
# 前端javascript模块化的演变发展
    1、IE6之前没有独立的JS引擎，javascript代码通过渲染引擎运行，所以几行javascript代码就能让页面奔溃。IE6之后，浏览器就有独立的JS引擎，程序员将所有的javascript代码写在html页面中的<script type='text/javascript'></script>中。
    2、随着页面越来越复杂，javascript代码越来越多，于是程序员就将javascript代码全部写在js的文件中，然后在html页面中用<script src="js/index.js"></script>来引入javascript代码。
    3、可随着javascript代码越来越多，每个html页面都要引入一个非常大的js文件。于是程序员就让每个html文件都有自己独立的js文件，然后引入。由此可见，此时的模块化就是，javascript以页面为基准来分成不同的javascript块。
    4、有些html会共用相同的javascript代码，每个js文件都写相同的javascript代码就会导致严重的冗余。因此程序员将多个html页面共用的javascript代码提取到一个common.js文件，即为公共文件，然后引用即可。
    5、（1）可随着common.js文件内容越来越多。有些html页面只需要用common.js中某一段代码，可它却需要引用common.js中全部的代码。因此造成页面引用了很多无用的javascript代码。
    （2）当html页面越来越多，公共的js文件也越来越多。引用多个js文件，系统从上往下逐一执行。因此js文件必须按照程序的逻辑排序，不然程序会报错。因为同一个html文件中的<script>共用同一个JS作用域，即全局作用域。（3）也就是说，所有的<script>引入的js文件中声明的全局变量和函数，都直接暴露在全局作用域中。因此，很容易出现重名问题导致变量覆盖。污染全局的概念是指，在全局作用域中声明数据类型(number\string\object\boolean)的变量。声明其他可控的变量，例如模块名，不构成污染全局。
    因此模块化需要解决：1、加载顺序，2、污染全局。
    污染全局的解决方法就是立即执行函数。函数在执行的时候会有自己的作用域和执行期上下文。全局作用域无法直接访问函数作用域中的内容。程序员在立即执行函数中编写代码，相当于是在函数作用域中编写代码。最后在通过return {}抛出所写的内容。{}就是执行期上下文中的变量和函数，抛出{}就形成了闭包。当立即执行函数执行完后就会销毁，可是由于形成了闭包的原因，函数的作用域并没有被销毁。闭包并不是直接存在于全局作用域下面的，而是存在于函数作用域，只不过闭包将函数作用域拉到全局作用域中。然后在全局作用域中通过变量接收return的{}。当模块A需要模块B中的变量时，就将接收了在全局作用域中包含模块B返回值的变量b，通过实参传递给模块A的立即执行函数。这样模块A就能使用模块B中的变量了，即b.xxx。传参的核心意义就是将全局变量变为函数内部的临时变量。由此，不仅解决了污染全局的问题，而且模块之间可以相互依赖了。由此可见，模块独立并且可相互依赖。
    6、插件化：开发者想用立即执行函数实现的模块来开发程序集合，例如轮播图。并且，开发者还想给程序集合提供一个配置项，让使用者可以通过不同的配置实现不同的功能设置。例如，轮播图切换的秒数。因此立即执行函数中就需要用构造函数实现程序功能。因为构造函数可以根据不同的配置参数，实例化出不同的实例对象。实例对象在全局作用域中，相当于是javascript代码在html中，从而就会执行程序（未知）。因此，使用插件都是通过实例化构造函数和传参来实现功能。
    7、以上都是通过javascript本身的功能实现模块化。可现在，NodeJS诞生了，它带来了前所未有的模块化体验。程序员只需要在电脑中安装了NodeJS，让代码在NodeJS环境下运行，程序员就可以module.exports 来导出用立即执行函数书写的模块。然后在使用require('.....')来引入模块，并将其赋给变量。这样程序员就可以通过变量来调用模块中的变量和函数。也就是说，程序员不在依赖html页面来实现模块之间的导入导出，即通过<script>逐一执行js文件，然后将全局作用域中的变量(模块)，通过参数传递的方式实现导入导出。而是依赖NodeJS来实现模块之间的导入导出。html页面中<script>只需要引入index.js文件即可。
    CommonJS是一种模块化规范，它来源于NodeJS，所以只能在NodeJS中运行。CommonJS使用的是同步方法，所有js文件都是同步完成加载。CommonJS每次require引用一个文件，都会创建一个模块实例，即js的实例，以便使用。CommonJS有缓存机制，只要模块被引用一次，那这个模块就会被缓存。如果下次使用模块的时候，模块没有更改，那就使用缓存中的这个模块。避免多次执行require这个动作。
    8、由于CommonJS在浏览器中运行不了，所以造出了AMD（Asynchronous Module Definition）异步模块定义，来实现浏览器上的导入导出模块。定义模块：define(moduleName, [module], factory); moduleName是模块名，[module]是这个模块依赖的模块名，factory是回调函数，它相当于是立即执行函数，factory函数内是这个模块里面需要干什么。
    引入模块：require([module], callback)。实现AMD的是RequireJS
    9、ES6官方终于给出了权威答案-ES6模块化。导出模块：1、默认暴露export default xxx。2、集体暴露export {}。导入模块：1、import 接收模块的变量名 from '模块文件路径'。2、集体导入import {模块名} from '模块文件路径'
    commonJS和ES6的区别：1、commonjs模块导出的是一个变量的拷贝。因此无论变量值如何改变，导入时接收到的依旧是原始变量的拷贝。然而，ES6模块导出的是变量的引用。也就是说，导入的变量就是导出的变量。因此导入的变量是导出模块操作完成后的变量。2、commonjs模块是在运行时加载，es6模块是在编译时加载。也就是说，es6的模块本身就是模块，只是浏览器不支持，所以需要webpack环境去编译它。它在编译了以后就已经存在了，运行的时候实际上并不是运行的原来写的模块，而是它编译好的程序。commonjs运行在服务端，是你引进来，在程序进行运行的时候，它require的同时才会去加载。

