<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script type="text/javascript">
        // 1、function简介
        /*
            function也是种基本数据类型。function是一个固定的功能或者是程序段被封装的过程，在这个封装体中需要
        一个入口和一个出口。入口就是参数，出口就是return。当需要使用这个功能时，就调用这个函数。
        可见，function并不是存储数据，而是操作数据。
            编程基本原则：高内聚，低耦合。高内聚：开发的功能模块的代码相关性强、联系紧密，这样模块的独立性就更强。
        我们希望一个模块能独立完成一个功能，并且它最好不依赖其他模块完成任务。低耦合：耦合就是各个代码块中重复的代码太多了。
        我们希望把重复的代码抽离出来，组成一个独立的功能模块，来完成一个特定的功能。
            函数定义的两种方式：
                1、function funName (){}。这种方式通常用于export
                2、const funName ()=>{}。这种方式更符合编程思想。
        */

        /*test1函数赋给test变量后，test1在全局作用域中就不可见，因此不能在全局作用域中执行test1，
        只能在函数体中执行。test在全局作用域中，所以可以在全局作用域中执行
         */
        let test = function test1() {
            let a = 1,
                b = 2;
            console.log(a, b)
            // test1()  //无限输出1，2
        }
        console.log(test.name) //test1
        test() //1,2
        // test1()  //test1 is not defined

        // 匿名函数表达式。
        let fun = function () { }

        // 2、函数的形参和实参
        /*
            函数的形参用于占位，它是未赋值的变量，需要在函数调用的时候，接受实参传递过来的值。实参和形参
        之间存在映射关系，实参的值会传递给形参。形参相当于是函数体中声明的临时变量，只不过它的值由实参赋值。
            实参和形参按照顺序赋值。当形参多于实参时，未赋值的形参就是undefined。实参多于形参，也不报错。
            参数也可以设置默认值。如果要使用形参的默认值，则实参设置为undefined。
            每个函数都有return。return既有终止函数执行的作用，又有返回函数执行结果的作用。
        未明确写return的函数系统会默认函数return undefined。
                    
                */

        function realVariate(a, b) {
            // arguments就是函数的实参
            console.log(arguments[1, 2, 3])
            console.log(realVariate.length) //2   形参的个数
            console.log(arguments.length) //3
        }

        realVariate(1, 2, 3)

        // 累加实参
        function sum() {
            let a = 0;
            for (let i = 0; i < arguments.length; i++) {
                a += arguments[i]
            }
            console.log(a)
        }

        sum(1, 2, 3, 4, 5, 6) //21


        function returnTest(name) {
            if (!name) {
                return `您没有填写姓名！`;
            }

            return name
            // return name || `您没有填写姓名！` name为真则返回，非真则返回后面的字符串
        }
        console.log(returnTest('xu'))


        // window和return的区别: window也是将函数变为全局函数，不过它不能终止函数。
        function testa() {
            let a = 1;

            function add() {
                a++;
                console.log(a)
            }
            // window.add = add;
            return add
        }
        let addfun = testa()
        addfun()
        addfun()
        addfun()

        // testa()
        // add()
        // add()
        // add()

        // 3、递归函数
        /*
            递归就是函数的返回值包含函数自身，因此函数会自己再次调用自己，直至返回值为非函数值，
        然后在计算出函数的最终结果值。由于，return返回最终结果会花比较长的时间，因此递归在性能方面不占优势。
            递归都需要通过if判断语句设置结束递归的条件。
        */

        // n的阶乘
        function fact(n) {
            if (n === 1) {
                return 1
            }
            return n * fact(n - 1)
        }

        /*
        fact(5) = 5 * fact(4); fact(4) = 4 * fact(3); fact(3) = 3 * fact(2); fact(2) = 2 * fact(1)
        */
        console.log(fact(5))

// 4、立即执行函数
/*
    表达式：1、任何东西被()括起来后，都会表达式。当函数声明被()括起来后，函数名就会被忽略。
2、+、 -、 !、 ||、 &&也能将函数声明变成函数表达式。
    函数表达式就可以通过执行符号()执行，即为立即执行函数。当函数表达式被定义时，它就会立即执行，执行完成
以后立即释放。由此可见，立即执行函数没有函数名，因为它无需函数名来调用函数。
    立即执行函数一般会在前面加; 表示断句。多个立即执行语句如果没有;断开，就会报错。
    立即执行函数的作用：解决污染全局问题和模块间相互依赖的问题
    污染全局的解决方法就是立即执行函数。函数在执行的时候会有自己的作用域和执行期上下文。全局作用域无法直接
访问函数作用域中的内容。程序员在立即执行函数中编写代码，相当于是在函数作用域中编写代码。最后在通过
return {}抛出所写的内容。{}就是执行期上下文中的变量和函数，抛出{}就形成了闭包。当立即执行函数执行完后
就会销毁，可是由于形成了闭包的原因，函数的作用域并没有被销毁。闭包并不是直接存在于全局作用域下面的，而是
存在于函数作用域，只不过闭包将函数作用域拉到全局作用域中。然后在全局作用域中通过变量接收return的{}。
当模块A需要模块B中的变量时，就将接收了模块B返回值的全局作用域中的变量b，通过实参传递给模块A的立即执行函数。
这样模块A就能使用模块B中的变量了，即b.xxx。由此，不仅解决了污染全局的问题，而且模块之间可以相互依赖了。
由此可见，模块独立并且可相互依赖。
            
        
            //案例二：test17执行的时候，for循环十次，arr数组保留十个函数，然后返回arr。这十个函数都是闭包。
            // 当执行arr中的函数时，通过作用域链函数会找到AO(test17)中的i。所以输出的是10个10
            function test17() {
            var arr = []
            // var i = 0;
            for(var i = 0; i < 10; i++){
                arr[i] = function(){
                    document.write(i + ' ')
                }
                // i++
            }
            return arr; 
            }
        
            var myArr = test();
            for(var j = 0;j < 10; j++){
                myArr[j]();
            }
        
            // 解决方法一：自执行函数
            function test18() {
            for(var i = 0; i < 10; i++){
                (function(){
                    document.write(i + ' ')
                })()
                }
            }
            // 解决方法二：因为是j是形参，所以匿名函数中的j也是形参值。立即执行函数又会将
            for(var i = 0; i < 10; i++){
                (function(j) {
                    arr[j] = function() {
                        document.write(j + ' ')
                    }
                })(i)
            }
        
            // 案例三：
            // function b(){}不是false的一种。if的判断条件也会预编译。 (function b(){})表达式忽略名字，因此函数不存在。
            var m = 10;
            if(function b(){}){
                m += typeof(n)
            }
        
            console.log(a) //10undefined
        
        */

        // 立即执行函数
        let num = (function (a, b) {
            return a + b
        })(1, 2)
        console.log(num) //3

        // 函数表达式
        var test2 = function () {
            console.log('d') //d
        }()
            // + - ！
            +
            function test3() {
                console.log('a') //a
            }()

        2 && function test4() {
            console.log('b') //b
        }()

        undefined || function test5() {
            console.log('c') //c
        }()

        /*这种情况不会报错也不会执行。test6是函数声明，无法通过()自执行。当()中传了参数，系统会以为(6)是表达式，
        而非立即执行符号。因此不会报错。如果没有参数，就会报错。
        */
        function test6(a6) {
            console.log(1)
        } (6)



        // 5、模块化开发，自执行函数相当于是一个伪全局，这样写可以防止污染全局。
        let initProgrammer = (function () {
            let Programmer = function () { }
            Programmer.prototype = {
                name: '程序员',
                tool: '计算机',
                work: '编写应用程序',
                duration: '10个小时',
                say: function () {
                    console.log(
                        `我是一名${this.myName}${this.name}，我的工作是用${this.tool}${this.work}，
                    我每天工作${this.duration}，我的工作需要用到${this.lang.toString()}。`
                    );
                }
            }
            function FrontEnd() { }
            function BackEnd() { }

            function inherit(Target, Origin) {
                function Buffer() { }
                Buffer.prototype = Origin.prototype;
                Target.prototype = new Buffer()
                // 继承后，Target.prototype.constructor = Origin，因此需要变为本身。
                Target.prototype.constructor = Target
                Target.prototype.super_class = Origin  //保存继承源，以便找到真正继承的构造函数。
            }

            inherit(FrontEnd, Programmer);
            inherit(BackEnd, Programmer);

            FrontEnd.prototype.lang = ['HTML', 'CSS', 'JavaScript'];
            FrontEnd.prototype.myName = '前端';

            BackEnd.prototype.lang = ['Node', 'Java', 'SQL'];
            BackEnd.prototype.myName = '后端'

            return {
                FrontEnd: FrontEnd,
                BackEnd: BackEnd
            }
        })()

        let frontEnd = new initProgrammer.FrontEnd();
        let backEnd = new initProgrammer.BackEnd();

        frontEnd.say();
        backEnd.say();

        // 把所有的功能封装到立即执行函数中，然后返回给一个变量。通过这个变量来操作。这就是模块化思想。按需执行。
        function init() {
            initCompute();
            initFunctions();
        }


        let initCompute = (function () {
            let a = 1,
                b = 2;
            function add() {
                console.log(a + b)
            }
            function minus() {
                console.log(a - b)
            }
            function mul() {
                console.log(a * b)
            }
            function div() {
                console.log(a / b)
            }

            return function () {
                add();
                minus();
                mul();
                div()
            }
        })()
        initCompute()
        let initFunctions = (function () {

        })()

            // 6、插件的标配：立即执行函数用于隔离作用域，防止污染全局作用域。自执行函数要在window环境下执行
            ; (function () {
                var Slider = function (opt) { }
                Slider.prototype = {}
                window.Slider = Slider;
            })()

        var slider = new Slider({})

    </script>
</body>

</html>